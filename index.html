<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe Ultimate</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --accent-color: #fd79a8;
            --bg-color: #f9f9f9;
            --card-color: #ffffff;
            --text-color: #333333;
            --shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
            --touch-target: 44px;
        }

        .dark-mode {
            --primary-color: #8a7cff;
            --secondary-color: #6c5ce7;
            --accent-color: #ff7aa8;
            --bg-color: #1a1a2e;
            --card-color: #16213e;
            --text-color: #f0f0f0;
            --shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: all 0.3s ease;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            font-size: 16px;
            line-height: 1.5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            min-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .logo {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            color: var(--accent-color);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .mode-toggle {
            background-color: var(--card-color);
            border: none;
            width: 60px;
            height: 30px;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            box-shadow: var(--shadow);
            min-height: var(--touch-target);
            min-width: 60px;
        }

        .mode-toggle::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--primary-color);
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
        }

        .dark-mode .mode-toggle::after {
            transform: translateX(30px);
        }

        .mode-toggle:focus {
            outline: 3px solid var(--accent-color);
            outline-offset: 2px;
        }

        .hearts {
            display: flex;
            gap: 8px;
            background-color: var(--card-color);
            padding: 8px 15px;
            border-radius: 50px;
            box-shadow: var(--shadow);
            position: relative;
            min-height: var(--touch-target);
            align-items: center;
        }

        .heart {
            color: #ff4757;
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }

        .heart.lost {
            color: #ccc;
        }

        .heart-restore-timer {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            font-size: 0.9rem;
            color: var(--primary-color);
            font-weight: bold;
            text-align: center;
            display: none;
        }

        .page {
            display: none;
            flex: 1;
        }

        .page.active {
            display: flex;
            flex-direction: column;
        }

        .hero {
            text-align: center;
            padding: 25px 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            color: white;
        }

        .hero h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .hero p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .card {
            background-color: var(--card-color);
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: var(--shadow);
        }

        .card h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.8rem;
        }

        .card h2 i {
            color: var(--accent-color);
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .option {
            background-color: var(--bg-color);
            padding: 20px;
            border-radius: var(--border-radius);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .option:hover, .option:focus {
            transform: translateY(-5px);
            border-color: var(--primary-color);
            outline: none;
        }

        .option.selected {
            border-color: var(--accent-color);
            background-color: rgba(253, 121, 168, 0.1);
        }

        .option i {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .option h3 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        .option p {
            font-size: 0.95rem;
            color: var(--text-color);
            opacity: 0.8;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: var(--shadow);
            min-height: var(--touch-target);
            min-width: 120px;
        }

        .btn:hover, .btn:focus {
            background-color: var(--secondary-color);
            transform: translateY(-3px);
            outline: 3px solid var(--accent-color);
            outline-offset: 2px;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-large {
            padding: 20px 40px;
            font-size: 1.3rem;
            margin-top: 20px;
            min-width: 200px;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        .btn:disabled:hover {
            background-color: #ccc;
            transform: none;
            outline: none;
        }

        .center {
            text-align: center;
            margin-top: auto;
            padding-top: 20px;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .players {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .player {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--card-color);
            padding: 15px 20px;
            border-radius: 50px;
            box-shadow: var(--shadow);
            min-height: var(--touch-target);
        }

        .player.active {
            border: 3px solid var(--accent-color);
        }

        .player-icon {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
        }

        .player-x {
            background-color: #6c5ce7;
            color: white;
        }

        .player-o {
            background-color: #fd79a8;
            color: white;
        }

        .game-info {
            background-color: var(--card-color);
            padding: 15px 25px;
            border-radius: 50px;
            font-weight: 600;
            box-shadow: var(--shadow);
            font-size: 1.1rem;
            min-height: var(--touch-target);
            display: flex;
            align-items: center;
        }

        .game-board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            width: 100%;
            flex: 1;
            min-height: 300px;
            max-height: 60vh;
            overflow: auto;
            padding: 10px;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        .game-board {
            display: grid;
            gap: 4px;
            background-color: var(--primary-color);
            padding: 4px;
            border-radius: 8px;
            max-width: 100%;
            min-width: min-content;
            position: relative;
        }

        .cell {
            background-color: var(--card-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            min-width: var(--touch-target);
            min-height: var(--touch-target);
            position: relative;
            z-index: 1;
        }

        .cell:hover, .cell:focus {
            background-color: var(--secondary-color);
            color: white;
            outline: 3px solid var(--accent-color);
            outline-offset: -2px;
        }

        .cell.x {
            color: #6c5ce7;
        }

        .cell.o {
            color: #fd79a8;
        }

        /* WINNING LINE - Only the line, no cell coloring */
        .winning-line {
            position: absolute;
            background-color: #ffeb3b;
            z-index: 0;
            border-radius: 4px;
            height: 8px;
            transform-origin: 0 0;
        }

        .board-3x3 .cell {
            width: 100px;
            height: 100px;
            font-size: 2.5rem;
        }

        .board-6x6 .cell {
            width: 60px;
            height: 60px;
            font-size: 1.8rem;
            min-width: 50px;
            min-height: 50px;
        }

        .board-9x9 .cell {
            width: 45px;
            height: 45px;
            font-size: 1.5rem;
            min-width: 40px;
            min-height: 40px;
        }

        .board-11x11 .cell {
            width: 40px;
            height: 40px;
            font-size: 1.3rem;
            min-width: 35px;
            min-height: 35px;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .selection-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .selection-modal.active {
            display: flex;
        }

        .selection-content {
            background-color: var(--card-color);
            padding: 30px;
            border-radius: var(--border-radius);
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .selection-content h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 2.2rem;
        }

        .selection-content p {
            margin-bottom: 25px;
            font-size: 1.2rem;
            color: var(--text-color);
            line-height: 1.6;
        }

        .selection-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 25px 0;
        }

        .selection-option {
            background-color: var(--bg-color);
            padding: 25px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            min-height: 140px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .selection-option:hover, .selection-option:focus {
            transform: translateY(-3px);
            border-color: var(--primary-color);
            outline: 3px solid var(--accent-color);
            outline-offset: -2px;
        }

        .selection-option.selected {
            border-color: var(--accent-color);
            background-color: rgba(253, 121, 168, 0.1);
        }

        .selection-option i {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .selection-option h3 {
            margin-bottom: 5px;
            color: var(--primary-color);
            font-size: 1.3rem;
        }

        .selection-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }

        .result-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .result-modal.active {
            display: flex;
        }

        .result-content {
            background-color: var(--card-color);
            padding: 40px;
            border-radius: var(--border-radius);
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        .result-content h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 2.5rem;
        }

        .result-content p {
            margin-bottom: 30px;
            font-size: 1.3rem;
            line-height: 1.6;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .no-hearts-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .no-hearts-modal.active {
            display: flex;
        }

        .no-hearts-content {
            background-color: var(--card-color);
            padding: 40px;
            border-radius: var(--border-radius);
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
        }

        .no-hearts-content h2 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 2.2rem;
        }

        .no-hearts-content p {
            margin-bottom: 25px;
            font-size: 1.2rem;
            color: var(--text-color);
            line-height: 1.6;
        }

        .timer-display {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary-color);
            margin: 20px 0;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: var(--border-radius);
            display: inline-block;
            min-width: 150px;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 25px;
        }
        
        .step {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #ddd;
            transition: all 0.3s ease;
        }
        
        .step.active {
            background-color: var(--primary-color);
            transform: scale(1.2);
        }
        
        .step.completed {
            background-color: var(--accent-color);
        }

        .skip-to-content {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary-color);
            color: white;
            padding: 8px;
            z-index: 100;
            text-decoration: none;
        }

        .skip-to-content:focus {
            top: 0;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        @media (max-width: 768px) {
            :root {
                --touch-target: 48px;
            }
            
            body {
                padding: 15px;
                font-size: 18px;
            }
            
            .container {
                padding: 15px;
            }
            
            .hero h1 {
                font-size: 2rem;
                line-height: 1.3;
            }
            
            .hero p {
                font-size: 1.1rem;
            }
            
            .logo {
                font-size: 1.8rem;
            }
            
            .board-3x3 .cell {
                width: 90px;
                height: 90px;
                font-size: 2.2rem;
            }
            
            .board-6x6 .cell {
                width: 55px;
                height: 55px;
                font-size: 1.6rem;
                min-width: 50px;
                min-height: 50px;
            }
            
            .board-9x9 .cell {
                width: 40px;
                height: 40px;
                font-size: 1.4rem;
                min-width: 38px;
                min-height: 38px;
            }
            
            .board-11x11 .cell {
                width: 35px;
                height: 35px;
                font-size: 1.2rem;
                min-width: 33px;
                min-height: 33px;
            }
            
            .game-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .options {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .option {
                padding: 25px 20px;
                min-height: 140px;
            }
            
            .option i {
                font-size: 2.8rem;
            }
            
            .option h3 {
                font-size: 1.4rem;
            }
            
            .header-controls {
                width: 100%;
                justify-content: center;
                margin-top: 15px;
                gap: 20px;
            }
            
            .selection-options {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .selection-option {
                min-height: 150px;
                padding: 30px 20px;
            }
            
            .selection-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .selection-buttons .btn {
                width: 100%;
            }
            
            .game-board-container {
                max-height: 55vh;
                padding: 5px;
                margin-bottom: 20px;
                touch-action: pan-y pinch-zoom;
            }
            
            .game-board {
                min-width: max-content;
                gap: 3px;
                padding: 3px;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .game-controls .btn {
                width: 100%;
                justify-content: center;
                padding: 18px;
                font-size: 1.2rem;
            }
            
            .player {
                padding: 12px 20px;
                min-height: 55px;
            }
            
            .player-icon {
                width: 40px;
                height: 40px;
                font-size: 1.6rem;
            }
            
            .game-info {
                padding: 12px 20px;
                font-size: 1.1rem;
                text-align: center;
                justify-content: center;
            }
            
            .btn {
                font-size: 1.2rem;
                padding: 16px 25px;
            }
            
            .btn-large {
                padding: 20px;
                font-size: 1.4rem;
                min-width: 100%;
            }
            
            .result-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .result-buttons .btn {
                width: 100%;
            }
            
            .card {
                padding: 20px;
            }
            
            .card h2 {
                font-size: 1.6rem;
            }
            
            @media (max-width: 480px) {
                body {
                    padding: 10px;
                }
                
                .container {
                    padding: 10px;
                }
                
                .board-3x3 .cell {
                    width: 80px;
                    height: 80px;
                    font-size: 2rem;
                }
                
                .board-6x6 .cell {
                    width: 50px;
                    height: 50px;
                    font-size: 1.5rem;
                    min-width: 45px;
                    min-height: 45px;
                }
                
                .board-9x9 .cell {
                    width: 35px;
                    height: 35px;
                    font-size: 1.3rem;
                    min-width: 32px;
                    min-height: 32px;
                }
                
                .board-11x11 .cell {
                    width: 30px;
                    height: 30px;
                    font-size: 1.1rem;
                    min-width: 28px;
                    min-height: 28px;
                }
                
                .hero h1 {
                    font-size: 1.8rem;
                }
                
                .hero {
                    padding: 20px 15px;
                }
                
                .game-board-container {
                    max-height: 50vh;
                }
                
                .option, .selection-option {
                    min-height: 130px;
                    padding: 20px 15px;
                }
                
                .option i, .selection-option i {
                    font-size: 2.5rem;
                }
            }
            
            @media (max-width: 360px) {
                .board-3x3 .cell {
                    width: 70px;
                    height: 70px;
                    font-size: 1.8rem;
                }
                
                .board-6x6 .cell {
                    width: 45px;
                    height: 45px;
                    font-size: 1.4rem;
                    min-width: 40px;
                    min-height: 40px;
                }
                
                .board-9x9 .cell {
                    width: 32px;
                    height: 32px;
                    font-size: 1.2rem;
                    min-width: 30px;
                    min-height: 30px;
                }
                
                .board-11x11 .cell {
                    width: 28px;
                    height: 28px;
                    font-size: 1rem;
                    min-width: 26px;
                    min-height: 26px;
                }
                
                .game-board-container {
                    max-height: 45vh;
                }
                
                .hero h1 {
                    font-size: 1.6rem;
                }
                
                .logo {
                    font-size: 1.6rem;
                }
            }
        }

        @media (prefers-contrast: high) {
            :root {
                --primary-color: #0000ff;
                --secondary-color: #0000aa;
                --accent-color: #ff0000;
                --text-color: #000000;
                --bg-color: #ffffff;
                --card-color: #f0f0f0;
            }
            
            .dark-mode {
                --primary-color: #ffff00;
                --secondary-color: #ffaa00;
                --accent-color: #ff5500;
                --text-color: #ffffff;
                --bg-color: #000000;
                --card-color: #222222;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 5px;
            border: 2px solid var(--bg-color);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-color);
        }
    </style>
    </head>
<body>
    <a href="#main-content" class="skip-to-content">Skip to game content</a>
    
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-gamepad"></i>
                <span>Tic Tac Toe Ultimate</span>
            </div>
            <div class="header-controls">
                <div class="hearts" id="hearts">
                    <i class="fas fa-heart heart"></i>
                    <i class="fas fa-heart heart"></i>
                    <i class="fas fa-heart heart"></i>
                    <div class="heart-restore-timer" id="heartTimer"></div>
                </div>
                <button class="mode-toggle" id="modeToggle"></button>
            </div>
        </header>

        <div class="page active" id="homePage">
            <section class="hero">
                <h1>Tic Tac Toe Ultimate</h1>
                <p>Challenge the AI with extreme difficulty levels. The classic game reimagined!</p>
            </section>

            <div class="card">
                <h2><i class="fas fa-th"></i> Board Selection</h2>
                <p>Select the board size and required matching sequence to win.</p>
                <div class="options" id="boardOptions">
                    <div class="option selected" data-size="3" data-match="3">
                        <i class="fas fa-border-all"></i>
                        <h3>3x3 Board</h3>
                        <p>Match 3 in a row to win</p>
                    </div>
                    <div class="option" data-size="6" data-match="4">
                        <i class="fas fa-border-all"></i>
                        <h3>6x6 Board</h3>
                        <p>Match 4 in a row to win</p>
                    </div>
                    <div class="option" data-size="9" data-match="5">
                        <i class="fas fa-border-all"></i>
                        <h3>9x9 Board</h3>
                        <p>Match 5 in a row to win</p>
                    </div>
                    <div class="option" data-size="11" data-match="6">
                        <i class="fas fa-border-all"></i>
                        <h3>11x11 Board</h3>
                        <p>Match 6 in a row to win</p>
                    </div>
                </div>
            </div>

            <div class="center">
                <button class="btn btn-large" id="nextButton">
                    <i class="fas fa-arrow-right"></i> Next
                </button>
            </div>
        </div>

        <div class="page" id="gamePage" role="main">
            <div class="game-header">
                <div class="players">
                    <div class="player active" id="playerX">
                        <div class="player-icon player-x">X</div>
                        <div class="player-info">
                            <h3>Player X</h3>
                            <p>You</p>
                        </div>
                    </div>
                    <div class="player" id="playerO">
                        <div class="player-icon player-o">O</div>
                        <div class="player-info">
                            <h3>Player O</h3>
                            <p id="opponentType">Bot (Easy)</p>
                        </div>
                    </div>
                </div>
                <div class="game-info">
                    <span id="currentTurn">Player X's Turn</span>
                </div>
            </div>

            <div class="game-board-container">
                <div class="game-board" id="gameBoard"></div>
            </div>

            <div class="game-controls">
                <button class="btn" id="restartButton">
                    <i class="fas fa-redo"></i> Restart Game
                </button>
                <button class="btn" id="homeButton">
                    <i class="fas fa-home"></i> Back to Home
                </button>
                <button class="btn" id="newGameButton">
                    <i class="fas fa-plus-circle"></i> New Board
                </button>
            </div>
        </div>

        <div class="selection-modal" id="selectionModal">
            <div class="selection-content">
                <div class="step-indicator" id="stepIndicator">
                    <div class="step active" id="step1"></div>
                    <div class="step" id="step2"></div>
                    <div class="step" id="step3"></div>
                </div>
                
                <h2 id="selectionTitle">Select Game Mode</h2>
                <p id="selectionDescription">Choose your game mode</p>
                
                <div class="selection-options" id="selectionOptions"></div>
                
                <div class="selection-buttons">
                    <button class="btn" id="backButton">
                        <i class="fas fa-arrow-left"></i> Back
                    </button>
                    <button class="btn" id="continueButton">
                        Continue <i class="fas fa-arrow-right"></i>
                    </button>
                </div>
            </div>
        </div>

        <div class="result-modal" id="resultModal">
            <div class="result-content">
                <h2 id="resultTitle">Game Over!</h2>
                <p id="resultMessage">Player X wins the game!</p>
                <div class="result-buttons">
                    <button class="btn" id="playAgainButton">
                        <i class="fas fa-play-circle"></i> Play Again
                    </button>
                    <button class="btn" id="modalHomeButton">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <div class="no-hearts-modal" id="noHeartsModal">
            <div class="no-hearts-content">
                <h2><i class="fas fa-heart-broken"></i> Out of Hearts!</h2>
                <p>You've lost all your hearts. Please wait for hearts to restore before playing again.</p>
                <div class="timer-display" id="timerDisplay">05:00</div>
                <p>Hearts restore automatically every 5 minutes.</p>
                <button class="btn" id="closeNoHeartsButton">
                    <i class="fas fa-home"></i> Back to Home
                </button>
            </div>
        </div>
    </div>

    <div id="turn-announcer" class="sr-only" aria-live="assertive" aria-atomic="true"></div>

    <script>
        // Game State Variables
        let gameState = {
            boardSize: 3,
            matchToWin: 3,
            playerType: 'bot',
            difficulty: 'easy',
            currentPlayer: 'X',
            gameBoard: [],
            gameActive: true,
            hearts: 3,
            darkMode: false,
            maxHearts: 3,
            heartRestoreTime: 300,
            heartTimer: null,
            selectionStep: 1,
            winningCells: [],
            winLine: null
        };

        // DOM Elements
        const homePage = document.getElementById('homePage');
        const gamePage = document.getElementById('gamePage');
        const gameBoard = document.getElementById('gameBoard');
        const heartsContainer = document.getElementById('hearts');
        const heartTimerElement = document.getElementById('heartTimer');
        const modeToggle = document.getElementById('modeToggle');
        const nextButton = document.getElementById('nextButton');
        const homeButton = document.getElementById('homeButton');
        const newGameButton = document.getElementById('newGameButton');
        const restartButton = document.getElementById('restartButton');
        const resultModal = document.getElementById('resultModal');
        const resultTitle = document.getElementById('resultTitle');
        const resultMessage = document.getElementById('resultMessage');
        const playAgainButton = document.getElementById('playAgainButton');
        const modalHomeButton = document.getElementById('modalHomeButton');
        const currentTurnElement = document.getElementById('currentTurn');
        const playerXElement = document.getElementById('playerX');
        const playerOElement = document.getElementById('playerO');
        const opponentTypeElement = document.getElementById('opponentType');
        const turnAnnouncer = document.getElementById('turn-announcer');
        const selectionModal = document.getElementById('selectionModal');
        const selectionTitle = document.getElementById('selectionTitle');
        const selectionDescription = document.getElementById('selectionDescription');
        const selectionOptions = document.getElementById('selectionOptions');
        const backButton = document.getElementById('backButton');
        const continueButton = document.getElementById('continueButton');
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const noHeartsModal = document.getElementById('noHeartsModal');
        const timerDisplay = document.getElementById('timerDisplay');
        const closeNoHeartsButton = document.getElementById('closeNoHeartsButton');
        const boardOptions = document.querySelectorAll('#boardOptions .option');

        // Selection steps data
        const selectionSteps = [
            {
                title: "Select Game Mode",
                description: "Choose your game mode",
                options: [
                    { id: 'bot', icon: 'fas fa-robot', title: 'Player vs Bot', description: 'Play against AI opponent' },
                    { id: 'player', icon: 'fas fa-user', title: 'Player vs Player', description: 'Two players on the same device' }
                ]
            },
            {
                title: "Select Difficulty Level",
                description: "Choose the AI difficulty level",
                options: [
                    { id: 'easy', icon: 'fas fa-star', title: 'Easy', description: 'Good for beginners' },
                    { id: 'medium', icon: 'fas fa-star', title: 'Medium', description: 'A balanced challenge' },
                    { id: 'hard', icon: 'fas fa-star', title: 'Hard', description: 'For experienced players' },
                    { id: 'expert', icon: 'fas fa-star', title: 'Expert', description: 'Extreme - Nearly unbeatable' }
                ]
            }
        ];

        // Initialize the game
        function init() {
            loadGameState();
            setupEventListeners();
            initAccessibility();
            updateHeartsDisplay();
            switchPage('home');
        }

        // Initialize accessibility features
        function initAccessibility() {
            addAriaLabels();
            setupKeyboardNavigation();
            document.documentElement.lang = 'en';
        }

        // Add ARIA labels to elements
        function addAriaLabels() {
            modeToggle.setAttribute('aria-label', 'Toggle dark mode');
            modeToggle.setAttribute('role', 'switch');
            modeToggle.setAttribute('aria-checked', gameState.darkMode);
            
            heartsContainer.setAttribute('aria-label', `Hearts: ${gameState.hearts} out of 3 remaining`);
            
            nextButton.setAttribute('aria-label', 'Next - Choose game settings');
            homeButton.setAttribute('aria-label', 'Back to home page');
            newGameButton.setAttribute('aria-label', 'Start new game with current settings');
            restartButton.setAttribute('aria-label', 'Restart current game');
            playAgainButton.setAttribute('aria-label', 'Play again with same settings');
            modalHomeButton.setAttribute('aria-label', 'Go back to home page');
            closeNoHeartsButton.setAttribute('aria-label', 'Close out of hearts message and return to home');
            backButton.setAttribute('aria-label', 'Go back to previous selection');
            continueButton.setAttribute('aria-label', 'Continue to next selection');
        }

        // Setup keyboard navigation
        function setupKeyboardNavigation() {
            const buttons = document.querySelectorAll('button, .option, .selection-option, .cell');
            buttons.forEach(btn => btn.setAttribute('tabindex', '0'));
            
            document.querySelectorAll('.option, .selection-option').forEach(option => {
                option.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        option.click();
                    }
                });
            });
            
            document.addEventListener('keydown', (e) => {
                if (!gamePage.classList.contains('active')) return;
                
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('cell')) {
                    const row = parseInt(activeElement.dataset.row);
                    const col = parseInt(activeElement.dataset.col);
                    let newRow = row;
                    let newCol = col;
                    
                    switch(e.key) {
                        case 'ArrowUp': newRow = Math.max(0, row - 1); break;
                        case 'ArrowDown': newRow = Math.min(gameState.boardSize - 1, row + 1); break;
                        case 'ArrowLeft': newCol = Math.max(0, col - 1); break;
                        case 'ArrowRight': newCol = Math.min(gameState.boardSize - 1, col + 1); break;
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            handleCellClick(row, col);
                            return;
                    }
                    
                    if (newRow !== row || newCol !== col) {
                        const newCell = document.querySelector(`.cell[data-row="${newRow}"][data-col="${newCol}"]`);
                        if (newCell) {
                            newCell.focus();
                            e.preventDefault();
                        }
                    }
                }
            });
        }

        // Load game state from localStorage
        function loadGameState() {
            const savedHearts = localStorage.getItem('ticTacToeHearts');
            if (savedHearts !== null) gameState.hearts = parseInt(savedHearts);
            
            const heartData = localStorage.getItem('ticTacToeHeartData');
            if (heartData) {
                try {
                    const data = JSON.parse(heartData);
                    const now = Date.now();
                    const timePassed = Math.floor((now - data.timestamp) / 1000);
                    
                    if (data.restoreTime > 0) {
                        gameState.heartRestoreTime = Math.max(0, data.restoreTime - timePassed);
                        const heartsRestored = Math.floor(timePassed / 300);
                        gameState.hearts = Math.min(gameState.maxHearts, gameState.hearts + heartsRestored);
                        
                        if (heartsRestored > 0) {
                            gameState.heartRestoreTime = 300 - (timePassed % 300);
                        }
                        
                        if (gameState.hearts < gameState.maxHearts && gameState.heartRestoreTime > 0) {
                            startHeartRestoration();
                        }
                    }
                } catch (e) {
                    console.error('Error loading heart data:', e);
                }
            }
        }

        // Save heart restoration data to localStorage
        function saveHeartData() {
            const heartData = {
                restoreTime: gameState.heartRestoreTime,
                timestamp: Date.now()
            };
            localStorage.setItem('ticTacToeHeartData', JSON.stringify(heartData));
        }

        // Set up all event listeners
        function setupEventListeners() {
            modeToggle.addEventListener('click', toggleDarkMode);
            nextButton.addEventListener('click', () => {
                if (gameState.hearts <= 0) {
                    showNoHeartsModal();
                    return;
                }
                showSelectionModal();
            });
            
            homeButton.addEventListener('click', () => switchPage('home'));
            newGameButton.addEventListener('click', createNewBoard);
            restartButton.addEventListener('click', restartGame);
            
            backButton.addEventListener('click', goBackInSelection);
            continueButton.addEventListener('click', continueSelection);
            
            playAgainButton.addEventListener('click', () => {
                resultModal.classList.remove('active');
                if (gameState.hearts <= 0) {
                    showNoHeartsModal();
                } else {
                    restartGame();
                }
            });
            
            modalHomeButton.addEventListener('click', () => {
                resultModal.classList.remove('active');
                switchPage('home');
            });
            
            closeNoHeartsButton.addEventListener('click', () => {
                noHeartsModal.classList.remove('active');
                switchPage('home');
            });
            
            boardOptions.forEach(option => {
                option.addEventListener('click', () => {
                    boardOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    gameState.boardSize = parseInt(option.dataset.size);
                    gameState.matchToWin = parseInt(option.dataset.match);
                });
                
                option.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        option.click();
                    }
                });
            });

            window.addEventListener('beforeunload', saveHeartData);
            window.addEventListener('resize', handleResize);
        }

        // Handle window resize
        function handleResize() {
            if (gamePage.classList.contains('active')) {
                renderBoard();
            }
        }

        // Toggle dark/light mode
        function toggleDarkMode() {
            gameState.darkMode = !gameState.darkMode;
            document.body.classList.toggle('dark-mode', gameState.darkMode);
            modeToggle.setAttribute('aria-checked', gameState.darkMode);
        }

        // Update hearts display
        function updateHeartsDisplay() {
            const hearts = heartsContainer.querySelectorAll('.heart');
            hearts.forEach((heart, index) => {
                if (index < gameState.hearts) {
                    heart.classList.remove('lost');
                } else {
                    heart.classList.add('lost');
                }
            });
            
            localStorage.setItem('ticTacToeHearts', gameState.hearts.toString());
            nextButton.disabled = gameState.hearts <= 0;
            saveHeartData();
        }

        // Start heart restoration timer
        function startHeartRestoration() {
            if (gameState.heartTimer) clearInterval(gameState.heartTimer);
            
            heartTimerElement.style.display = 'block';
            updateTimerDisplay();
            
            gameState.heartTimer = setInterval(() => {
                gameState.heartRestoreTime--;
                updateTimerDisplay();
                saveHeartData();
                
                if (gameState.heartRestoreTime <= 0) {
                    gameState.hearts = Math.min(gameState.maxHearts, gameState.hearts + 1);
                    updateHeartsDisplay();
                    
                    if (gameState.hearts >= gameState.maxHearts) {
                        clearInterval(gameState.heartTimer);
                        heartTimerElement.style.display = 'none';
                        localStorage.removeItem('ticTacToeHeartData');
                    } else {
                        gameState.heartRestoreTime = 300;
                        saveHeartData();
                    }
                }
            }, 1000);
        }

        // Update timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.heartRestoreTime / 60);
            const seconds = gameState.heartRestoreTime % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            heartTimerElement.textContent = `Next heart: ${timeString}`;
            timerDisplay.textContent = timeString;
        }

        // Show no hearts modal
        function showNoHeartsModal() {
            if (gameState.hearts === 0 && !gameState.heartTimer) {
                gameState.heartRestoreTime = 300;
                startHeartRestoration();
            }
            updateTimerDisplay();
            noHeartsModal.classList.add('active');
        }

        // Switch between home and game pages
        function switchPage(page) {
            if (page === 'home') {
                homePage.classList.add('active');
                gamePage.classList.remove('active');
            } else if (page === 'game') {
                homePage.classList.remove('active');
                gamePage.classList.add('active');
            }
        }

        // Show selection modal
        function showSelectionModal() {
            gameState.selectionStep = 1;
            updateSelectionModal();
            selectionModal.classList.add('active');
        }

        // Update selection modal based on current step
        function updateSelectionModal() {
            step1.classList.toggle('active', gameState.selectionStep === 1);
            step1.classList.toggle('completed', gameState.selectionStep > 1);
            step2.classList.toggle('active', gameState.selectionStep === 2);
            step2.classList.toggle('completed', gameState.selectionStep > 2);
            step3.classList.toggle('active', gameState.selectionStep === 3);
            
            let currentStep;
            if (gameState.selectionStep === 1) {
                currentStep = selectionSteps[0];
            } else if (gameState.selectionStep === 2) {
                currentStep = selectionSteps[1];
                if (gameState.playerType !== 'bot') {
                    gameState.selectionStep = 3;
                    updateSelectionModal();
                    return;
                }
            } else if (gameState.selectionStep === 3) {
                selectionModal.classList.remove('active');
                startGame();
                return;
            }
            
            selectionTitle.textContent = currentStep.title;
            selectionDescription.textContent = currentStep.description;
            selectionOptions.innerHTML = '';
            
            currentStep.options.forEach(option => {
                const optionElement = document.createElement('div');
                optionElement.className = 'selection-option';
                optionElement.dataset.id = option.id;
                optionElement.setAttribute('tabindex', '0');
                optionElement.setAttribute('role', 'button');
                optionElement.setAttribute('aria-label', `${option.title}: ${option.description}`);
                
                optionElement.innerHTML = `
                    <i class="${option.icon}"></i>
                    <h3>${option.title}</h3>
                    <p>${option.description}</p>
                `;
                
                if (gameState.selectionStep === 1 && option.id === gameState.playerType) {
                    optionElement.classList.add('selected');
                } else if (gameState.selectionStep === 2 && option.id === gameState.difficulty) {
                    optionElement.classList.add('selected');
                }
                
                optionElement.addEventListener('click', () => {
                    selectionOptions.querySelectorAll('.selection-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    optionElement.classList.add('selected');
                    
                    if (gameState.selectionStep === 1) {
                        gameState.playerType = option.id;
                    } else if (gameState.selectionStep === 2) {
                        gameState.difficulty = option.id;
                    }
                });
                
                optionElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        optionElement.click();
                    }
                });
                
                selectionOptions.appendChild(optionElement);
            });
            
            backButton.style.display = 'inline-flex';
        }

        // Go back in selection process
        function goBackInSelection() {
            if (gameState.selectionStep > 1) {
                gameState.selectionStep--;
                updateSelectionModal();
            } else {
                selectionModal.classList.remove('active');
            }
        }

        // Continue in selection process
        function continueSelection() {
            const selectedOption = selectionOptions.querySelector('.selected');
            if (!selectedOption) {
                alert('Please select an option to continue');
                return;
            }
            
            if (gameState.selectionStep === 1) {
                gameState.playerType = selectedOption.dataset.id;
            } else if (gameState.selectionStep === 2) {
                gameState.difficulty = selectedOption.dataset.id;
            }
            
            gameState.selectionStep++;
            updateSelectionModal();
        }

        // Start the game
        function startGame() {
            if (gameState.hearts <= 0) {
                showNoHeartsModal();
                return;
            }
            
            if (gameState.playerType === 'bot') {
                opponentTypeElement.textContent = `Bot (${gameState.difficulty.charAt(0).toUpperCase() + gameState.difficulty.slice(1)})`;
            } else {
                opponentTypeElement.textContent = 'Player 2';
            }
            
            switchPage('game');
            createNewBoard();
        }

        // Create a new game board
        function createNewBoard() {
            gameState.currentPlayer = 'X';
            gameState.gameActive = true;
            gameState.winningCells = [];
            gameState.winLine = null;
            gameState.gameBoard = Array(gameState.boardSize).fill().map(() => Array(gameState.boardSize).fill(''));
            updatePlayerTurn();
            renderBoard();
        }

        // Restart the current game
        function restartGame() {
            if (gameState.hearts <= 0) {
                showNoHeartsModal();
                return;
            }
            createNewBoard();
        }

        // Render the game board
        function renderBoard() {
            gameBoard.innerHTML = '';
            gameBoard.classList.remove('board-3x3', 'board-6x6', 'board-9x9', 'board-11x11');
            gameBoard.classList.add(`board-${gameState.boardSize}x${gameState.boardSize}`);
            
            // Remove existing winning line
            if (gameState.winLine && gameState.winLine.parentNode === gameBoard) {
                gameBoard.removeChild(gameState.winLine);
            }
            
            const cellSize = calculateCellSize();
            gameBoard.style.gridTemplateColumns = `repeat(${gameState.boardSize}, ${cellSize}px)`;
            
            for (let row = 0; row < gameState.boardSize; row++) {
                for (let col = 0; col < gameState.boardSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.setAttribute('role', 'button');
                    cell.setAttribute('tabindex', '0');
                    
                    let ariaLabel = `Row ${row + 1}, Column ${col + 1}`;
                    
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    
                    const fontSize = Math.max(16, cellSize * 0.4);
                    cell.style.fontSize = `${fontSize}px`;
                    
                    if (gameState.gameBoard[row][col] === 'X') {
                        cell.textContent = 'X';
                        cell.classList.add('x');
                        ariaLabel += ', X marked';
                    } else if (gameState.gameBoard[row][col] === 'O') {
                        cell.textContent = 'O';
                        cell.classList.add('o');
                        ariaLabel += ', O marked';
                    } else {
                        ariaLabel += ', Empty';
                    }
                    
                    // REMOVED: Cell coloring for winning cells
                    // Only the line will be drawn
                    
                    cell.setAttribute('aria-label', ariaLabel);
                    
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    cell.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            handleCellClick(row, col);
                        }
                    });
                    
                    gameBoard.appendChild(cell);
                }
            }
            
            // Draw winning line if there is one
            if (gameState.winningCells.length > 0) {
                drawWinningLine();
            }
        }

        // Draw winning line ONLY (no cell coloring)
        function drawWinningLine() {
            if (gameState.winningCells.length < 2) return;
            
            const first = gameState.winningCells[0];
            const last = gameState.winningCells[gameState.winningCells.length - 1];
            const cellSize = calculateCellSize();
            const gap = 4;
            
            const line = document.createElement('div');
            line.className = 'winning-line';
            
            // Calculate line position and dimensions
            const x1 = first.col * (cellSize + gap) + cellSize / 2;
            const y1 = first.row * (cellSize + gap) + cellSize / 2;
            const x2 = last.col * (cellSize + gap) + cellSize / 2;
            const y2 = last.row * (cellSize + gap) + cellSize / 2;
            
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}deg)`;
            
            gameBoard.appendChild(line);
            gameState.winLine = line;
        }

        // Calculate optimal cell size
        function calculateCellSize() {
            const screenWidth = window.innerWidth;
            const boardSize = gameState.boardSize;
            
            if (screenWidth <= 480) {
                if (boardSize <= 3) return 70;
                if (boardSize <= 6) return 45;
                if (boardSize <= 9) return 35;
                return 30;
            } else if (screenWidth <= 768) {
                if (boardSize <= 3) return 80;
                if (boardSize <= 6) return 50;
                if (boardSize <= 9) return 40;
                return 35;
            } else {
                if (boardSize <= 3) return 90;
                if (boardSize <= 6) return 55;
                if (boardSize <= 9) return 45;
                return 40;
            }
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (!gameState.gameActive || gameState.gameBoard[row][col] !== '') {
                return;
            }
            
            makeMove(row, col, gameState.currentPlayer);
            
            if (checkWin(gameState.currentPlayer)) {
                endGame(`${gameState.currentPlayer === 'X' ? 'Player X' : 'Player O'} wins!`, false);
                return;
            }
            
            if (checkDraw()) {
                endGame("It's a draw!", true);
                return;
            }
            
            gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
            updatePlayerTurn();
            
            if (gameState.playerType === 'bot' && gameState.currentPlayer === 'O' && gameState.gameActive) {
                setTimeout(makeBotMove, 500);
            }
        }

        // Make a move on the board
        function makeMove(row, col, player) {
            gameState.gameBoard[row][col] = player;
            renderBoard();
        }

        // Update the player turn display
        function updatePlayerTurn() {
            const playerName = gameState.currentPlayer === 'X' ? 'Player X' : 'Player O';
            currentTurnElement.textContent = `${playerName}'s Turn`;
            turnAnnouncer.textContent = `${playerName}'s turn`;
            
            playerXElement.setAttribute('aria-label', 
                `Player X ${gameState.currentPlayer === 'X' ? '(Current turn)' : ''}`);
            playerOElement.setAttribute('aria-label', 
                `Player O ${gameState.currentPlayer === 'O' ? '(Current turn)' : ''}`);
            
            if (gameState.currentPlayer === 'X') {
                playerXElement.classList.add('active');
                playerOElement.classList.remove('active');
            } else {
                playerXElement.classList.remove('active');
                playerOElement.classList.add('active');
            }
        }

        // ============ AI FUNCTIONS ============

        // Make a move for the bot
        function makeBotMove() {
            if (!gameState.gameActive) return;
            
            let row, col;
            
            switch(gameState.difficulty) {
                case 'easy':
                    if (Math.random() < 0.3) {
                        [row, col] = getSmartMove();
                    } else {
                        [row, col] = getRandomMove();
                    }
                    break;
                    
                case 'medium':
                    if (Math.random() < 0.6) {
                        [row, col] = getSmartMove();
                    } else {
                        [row, col] = getRandomMove();
                    }
                    break;
                    
                case 'hard':
                    if (Math.random() < 0.8) {
                        [row, col] = getEnhancedSmartMove();
                    } else {
                        [row, col] = getSmartMove();
                    }
                    break;
                    
                case 'expert':
                    [row, col] = getExpertMove();
                    break;
            }
            
            makeMove(row, col, 'O');
            
            if (checkWin('O')) {
                endGame("Bot wins!", false);
                if (gameState.playerType === 'bot') {
                    gameState.hearts = Math.max(0, gameState.hearts - 1);
                    updateHeartsDisplay();
                    
                    if (gameState.hearts === 0) {
                        gameState.heartRestoreTime = 300;
                        startHeartRestoration();
                    }
                }
                return;
            }
            
            if (checkDraw()) {
                endGame("It's a draw!", true);
                return;
            }
            
            gameState.currentPlayer = 'X';
            updatePlayerTurn();
        }

        // Get a random empty cell
        function getRandomMove() {
            const emptyCells = [];
            
            for (let row = 0; row < gameState.boardSize; row++) {
                for (let col = 0; col < gameState.boardSize; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        emptyCells.push([row, col]);
                    }
                }
            }
            
            if (emptyCells.length === 0) return [0, 0];
            
            const randomIndex = Math.floor(Math.random() * emptyCells.length);
            return emptyCells[randomIndex];
        }

        // Get a smart move (checks wins and blocks)
        function getSmartMove() {
            const size = gameState.boardSize;
            const match = gameState.matchToWin;
            
            // 1. Try to win immediately
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'O';
                        if (checkWin('O')) {
                            gameState.gameBoard[row][col] = '';
                            return [row, col];
                        }
                        gameState.gameBoard[row][col] = '';
                    }
                }
            }
            
            // 2. Try to block player from winning
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'X';
                        if (checkWin('X')) {
                            gameState.gameBoard[row][col] = '';
                            return [row, col];
                        }
                        gameState.gameBoard[row][col] = '';
                    }
                }
            }
            
            // 3. Take center if available
            const center = Math.floor(size / 2);
            if (gameState.boardSize % 2 === 1 && gameState.gameBoard[center][center] === '') {
                return [center, center];
            }
            
            // 4. Take corners
            const corners = [
                [0, 0],
                [0, size - 1],
                [size - 1, 0],
                [size - 1, size - 1]
            ];
            
            const availableCorners = corners.filter(([row, col]) => gameState.gameBoard[row][col] === '');
            if (availableCorners.length > 0) {
                const randomCorner = availableCorners[Math.floor(Math.random() * availableCorners.length)];
                return randomCorner;
            }
            
            // 5. Fallback to random
            return getRandomMove();
        }

        // Enhanced smart move
        function getEnhancedSmartMove() {
            const size = gameState.boardSize;
            const match = gameState.matchToWin;
            
            // 1. Check for immediate win
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'O';
                        if (checkWin('O')) {
                            gameState.gameBoard[row][col] = '';
                            return [row, col];
                        }
                        gameState.gameBoard[row][col] = '';
                    }
                }
            }
            
            // 2. Check for immediate block
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'X';
                        if (checkWin('X')) {
                            gameState.gameBoard[row][col] = '';
                            return [row, col];
                        }
                        gameState.gameBoard[row][col] = '';
                    }
                }
            }
            
            // 3. Look for strategic positions
            const strategicMoves = [];
            const center = Math.floor(size / 2);
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        let score = 0;
                        
                        // Score based on proximity to other O's
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                                    if (gameState.gameBoard[newRow][newCol] === 'O') score += 3;
                                    else if (gameState.gameBoard[newRow][newCol] === 'X') score += 1;
                                }
                            }
                        }
                        
                        // Prefer center positions
                        const distFromCenter = Math.abs(row - center) + Math.abs(col - center);
                        score += Math.max(0, (size - distFromCenter));
                        
                        strategicMoves.push({row, col, score});
                    }
                }
            }
            
            if (strategicMoves.length > 0) {
                strategicMoves.sort((a, b) => b.score - a.score);
                return [strategicMoves[0].row, strategicMoves[0].col];
            }
            
            return getRandomMove();
        }

        // Expert move - uses pattern recognition for all board sizes
        function getExpertMove() {
            const size = gameState.boardSize;
            const match = gameState.matchToWin;
            
            // For 3x3 board, use minimax (perfect play)
            if (size === 3 && match === 3) {
                return getBestMove3x3();
            }
            
            // 1. Check for immediate win (highest priority)
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'O';
                        if (checkWin('O')) {
                            gameState.gameBoard[row][col] = '';
                            return [row, col];
                        }
                        gameState.gameBoard[row][col] = '';
                    }
                }
            }
            
            // 2. Check for immediate block (second priority)
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'X';
                        if (checkWin('X')) {
                            gameState.gameBoard[row][col] = '';
                            return [row, col];
                        }
                        gameState.gameBoard[row][col] = '';
                    }
                }
            }
            
            // 3. Look for creating multiple threats (for large boards)
            if (size >= 6) {
                const threatMove = findBestThreatMove();
                if (threatMove) return threatMove;
            }
            
            // 4. Use board evaluation for best position
            const bestMove = evaluateBoardPosition();
            if (bestMove) return bestMove;
            
            // 5. Fallback to enhanced smart move
            return getEnhancedSmartMove();
        }

        // Find best threat move for expert AI
        function findBestThreatMove() {
            const size = gameState.boardSize;
            const match = gameState.matchToWin;
            const bestMoves = [];
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        let threatScore = 0;
                        
                        // Check all directions for potential
                        const directions = [
                            [0, 1], [1, 0], [1, 1], [1, -1]
                        ];
                        
                        for (const [dr, dc] of directions) {
                            let forwardO = 0, backwardO = 0;
                            let forwardEmpty = 0, backwardEmpty = 0;
                            
                            // Check forward
                            for (let i = 1; i < match; i++) {
                                const newRow = row + dr * i;
                                const newCol = col + dc * i;
                                if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                                    if (gameState.gameBoard[newRow][newCol] === 'O') forwardO++;
                                    else if (gameState.gameBoard[newRow][newCol] === '') forwardEmpty++;
                                    else break;
                                } else break;
                            }
                            
                            // Check backward
                            for (let i = 1; i < match; i++) {
                                const newRow = row - dr * i;
                                const newCol = col - dc * i;
                                if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                                    if (gameState.gameBoard[newRow][newCol] === 'O') backwardO++;
                                    else if (gameState.gameBoard[newRow][newCol] === '') backwardEmpty++;
                                    else break;
                                } else break;
                            }
                            
                            const totalO = forwardO + backwardO;
                            const totalEmpty = forwardEmpty + backwardEmpty;
                            
                            if (totalO >= match - 2 && totalEmpty >= 1) {
                                threatScore += 10;
                            } else if (totalO >= match - 3 && totalEmpty >= 2) {
                                threatScore += 5;
                            }
                        }
                        
                        if (threatScore > 0) {
                            bestMoves.push({row, col, score: threatScore});
                        }
                    }
                }
            }
            
            if (bestMoves.length > 0) {
                bestMoves.sort((a, b) => b.score - a.score);
                const topMoves = bestMoves.slice(0, Math.min(3, bestMoves.length));
                return topMoves[Math.floor(Math.random() * topMoves.length)];
            }
            
            return null;
        }

        // Evaluate board position for expert AI
        function evaluateBoardPosition() {
            const size = gameState.boardSize;
            const moves = [];
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        let score = 0;
                        
                        // Center control
                        const center = Math.floor(size / 2);
                        const distanceFromCenter = Math.abs(row - center) + Math.abs(col - center);
                        score += (size - distanceFromCenter) * 2;
                        
                        // Cluster with other O's
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                                    if (gameState.gameBoard[newRow][newCol] === 'O') score += 5;
                                    else if (gameState.gameBoard[newRow][newCol] === 'X') score += 2;
                                }
                            }
                        }
                        
                        moves.push({row, col, score});
                    }
                }
            }
            
            if (moves.length === 0) return null;
            
            moves.sort((a, b) => b.score - a.score);
            const topMoves = moves.slice(0, Math.min(3, moves.length));
            return [topMoves[0].row, topMoves[0].col];
        }

        // Minimax for 3x3 board only
        function getBestMove3x3() {
            let bestScore = -Infinity;
            let bestMove;
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        gameState.gameBoard[row][col] = 'O';
                        let score = minimax3x3(0, false);
                        gameState.gameBoard[row][col] = '';
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = [row, col];
                        }
                    }
                }
            }
            
            return bestMove || getRandomMove();
        }

        // Minimax algorithm for 3x3
        function minimax3x3(depth, isMaximizing) {
            if (checkWin('O')) return 10 - depth;
            if (checkWin('X')) return depth - 10;
            if (checkDraw()) return 0;
            
            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        if (gameState.gameBoard[row][col] === '') {
                            gameState.gameBoard[row][col] = 'O';
                            let score = minimax3x3(depth + 1, false);
                            gameState.gameBoard[row][col] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        if (gameState.gameBoard[row][col] === '') {
                            gameState.gameBoard[row][col] = 'X';
                            let score = minimax3x3(depth + 1, true);
                            gameState.gameBoard[row][col] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                }
                return bestScore;
            }
        }

        // ============ GAME LOGIC ============

        // Check for a win - FIXED VERSION
        function checkWin(player) {
            const board = gameState.gameBoard;
            const size = gameState.boardSize;
            const match = gameState.matchToWin;
            
            gameState.winningCells = [];
            
            // Check rows
            for (let row = 0; row < size; row++) {
                for (let col = 0; col <= size - match; col++) {
                    let win = true;
                    for (let k = 0; k < match; k++) {
                        if (board[row][col + k] !== player) {
                            win = false;
                            break;
                        }
                    }
                    if (win) {
                        for (let k = 0; k < match; k++) {
                            gameState.winningCells.push({row: row, col: col + k});
                        }
                        return true;
                    }
                }
            }
            
            // Check columns
            for (let col = 0; col < size; col++) {
                for (let row = 0; row <= size - match; row++) {
                    let win = true;
                    for (let k = 0; k < match; k++) {
                        if (board[row + k][col] !== player) {
                            win = false;
                            break;
                        }
                    }
                    if (win) {
                        for (let k = 0; k < match; k++) {
                            gameState.winningCells.push({row: row + k, col: col});
                        }
                        return true;
                    }
                }
            }
            
            // Check diagonals (top-left to bottom-right)
            for (let row = 0; row <= size - match; row++) {
                for (let col = 0; col <= size - match; col++) {
                    let win = true;
                    for (let k = 0; k < match; k++) {
                        if (board[row + k][col + k] !== player) {
                            win = false;
                            break;
                        }
                    }
                    if (win) {
                        for (let k = 0; k < match; k++) {
                            gameState.winningCells.push({row: row + k, col: col + k});
                        }
                        return true;
                    }
                }
            }
            
            // Check diagonals (top-right to bottom-left)
            for (let row = 0; row <= size - match; row++) {
                for (let col = match - 1; col < size; col++) {
                    let win = true;
                    for (let k = 0; k < match; k++) {
                        if (board[row + k][col - k] !== player) {
                            win = false;
                            break;
                        }
                    }
                    if (win) {
                        for (let k = 0; k < match; k++) {
                            gameState.winningCells.push({row: row + k, col: col - k});
                        }
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Check for a draw
        function checkDraw() {
            for (let row = 0; row < gameState.boardSize; row++) {
                for (let col = 0; col < gameState.boardSize; col++) {
                    if (gameState.gameBoard[row][col] === '') {
                        return false;
                    }
                }
            }
            return true;
        }

        // End the game
        function endGame(message, isDraw) {
            gameState.gameActive = false;
            resultTitle.textContent = isDraw ? "Game Draw!" : "Game Over!";
            resultMessage.textContent = message;
            
            turnAnnouncer.textContent = isDraw ? "Game ended in a draw" : message;
            
            if (gameState.hearts > 0) {
                playAgainButton.style.display = 'inline-flex';
            } else {
                playAgainButton.style.display = 'none';
            }
            
            renderBoard();
            
            setTimeout(() => {
                resultModal.classList.add('active');
            }, 500);
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
